import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from matplotlib.animation import FuncAnimation, PillowWriter

# Function that reads the output generated by the simulation. Returns three lists:
# [times]       -> List of each time that was simulated.
# [[x_coord_of_alive_cells]]    -> List of each x coordinate of the alive cells for each time.
# [[y_coord_of_alive_cells]]    -> List of each y coordinate of the alive cells for each time.
def read_output(board_size):
    times = []
    x_coords = []
    y_coords = []
    index = -1      # Index of the current time.
    with open('output/pdevs.log', 'r') as f:
        lines = f.readlines()
        for line in lines:
            if line.startswith('Simulation'):
                continue

            data = line.split(', ')    # Split the line into a list of data.

            # If the time is not in the list, add it.
            if (float(data[0]) not in times):
                times.append(float(data[0]))
                x_coords.append([])
                y_coords.append([])
                index += 1      # Advance to the next time.

            # Only if the cell is alive, add its coordinates to the list.
            if (float(data[2]) == 1.0):
                cell_number = int(data[1].strip("Cell"))
                x, y = cell_number % board_size, cell_number // board_size
                x_coords[index].append(x)
                y_coords[index].append(y)

    return times, x_coords, y_coords


# Function that generates a plot for each time that was simulated.
# This function was made with testing purposes.
def test_plot(times, x_coords, y_coords, board_size):
    for i in range(len(times)):
        make_plot(times[i], x_coords[i], y_coords[i], board_size)

# Function that generates a plot for a specific time, and specific coordinates.
# This function was made with testing purposes.
# Plot Configuration can be modified according to the simulation size.
def make_plot(time, x_coords, y_coords, board_size):
    plt.style.use('fast')

    # Data to plot
    x = np.array(x_coords)
    y = np.array(y_coords)

    #--------------------------# Plot Configuration. #--------------------------#
    # Create figure and axes.
    fig, ax = plt.subplots()

    # Set axis limits (Plot size).
    ax.set_xlim(0, board_size)  # To show all the coordinates from 0 to N
    ax.set_ylim(0, board_size)  # To show all the coordinates from 0 to N

    # Set background color and grid.
    ax.set_facecolor('#F8F8F8')  # Light gray background.
    ax.grid(color='gray', linestyle='-', linewidth=0.5)

    # Calculate the size of scatter points based on the board size.
    cell_size = 250 * (10 / board_size)  # Adjust this scaling factor as needed.

    # Set each point representing an alive cell with the data from the simulation.
    ax.scatter([coord + 0.5 for coord in x], [coord + 0.5 for coord in y], s=cell_size, color='#006699', marker='s')  # Shift the points to be centered in grid cells.
    
    ax.invert_yaxis()       # Invert the y axis to match the simulation.
    ax.xaxis.tick_top()     # Move the x axis to the top of the plot.
    ax.set_title('Game of Life')    # Set the title of the plot.

    # Set aspect ratio to 1:1 to make cells appear as squares.
    ax.set_aspect('equal')

    trans = ax.get_xaxis_transform()
    ax.annotate(f"Time: {time}", (0, -0.1), xycoords=trans, fontsize=12, color='red', annotation_clip=False)    # Add the time to the plot.

    # Add grid lines for every number in the range of 0 to board_size in x and y axes.
    ax.set_xticks(np.arange(board_size))
    ax.set_yticks(np.arange(board_size))

    # Center x tick labels between ticks.
    ax.xaxis.set_major_formatter(ticker.NullFormatter())
    ax.xaxis.set_minor_locator(ticker.FixedLocator([i + 0.5 for i in np.arange(board_size)]))
    ax.xaxis.set_minor_formatter(ticker.FixedFormatter(np.arange(board_size)))

    # Center y tick labels between ticks.
    ax.yaxis.set_major_formatter(ticker.NullFormatter())
    ax.yaxis.set_minor_locator(ticker.FixedLocator([i + 0.5 for i in np.arange(board_size)]))
    ax.yaxis.set_minor_formatter(ticker.FixedFormatter(np.arange(board_size)))
    
    plt.show()
    
# Function that generates an animation of the simulation.
# Plot Configuration can be modified according to the simulation size.
def make_animation(times, x_coords, y_coords, board_size, animation_name):
    plt.style.use('fast')
    fig, ax = plt.subplots()

    def update(frame):
        ax.clear()      # Clear the plot to update it.
        time = times[frame]     # Get the current time.
        x = x_coords[frame]     # Get the x coordinates of the alive cells.
        y = y_coords[frame]     # Get the y coordinates of the alive cells.

        # Set axis limits (Plot size).
        ax.set_xlim(0, board_size)  # To show all the coordinates from 0 to N
        ax.set_ylim(0, board_size)  # To show all the coordinates from 0 to N

        # Set background color and grid.
        ax.set_facecolor('#F8F8F8')  # Light gray background.
        ax.grid(color='gray', linestyle='-', linewidth=0.5)

        # Calculate the size of scatter points based on the board size.
        cell_size = 250 * (10 / board_size)  # Adjust this scaling factor as needed.

        # Set each point representing an alive cell with the data from the simulation.
        ax.scatter([coord + 0.5 for coord in x], [coord + 0.5 for coord in y], s=cell_size, color='#006699', marker='s')  # Shift the points to be centered in grid cells.
        
        ax.invert_yaxis()       # Invert the y axis to match the simulation.
        ax.xaxis.tick_top()     # Move the x axis to the top of the plot.
        ax.set_title('Game of Life')    # Set the title of the plot.

        # Set aspect ratio to 1:1 to make cells appear as squares.
        ax.set_aspect('equal')

        trans = ax.get_xaxis_transform()
        ax.annotate(f"Time: {time}", (0, -0.1), xycoords=trans, fontsize=12, color='red', annotation_clip=False)    # Add the time to the plot.

        # Add grid lines for every number in the range of 0 to board_size in x and y axes.
        ax.set_xticks(np.arange(board_size))
        ax.set_yticks(np.arange(board_size))

        # Center x tick labels between ticks.
        ax.xaxis.set_major_formatter(ticker.NullFormatter())
        ax.xaxis.set_minor_locator(ticker.FixedLocator([i + 0.5 for i in np.arange(board_size)]))
        ax.xaxis.set_minor_formatter(ticker.FixedFormatter(np.arange(board_size)))

        # Center y tick labels between ticks.
        ax.yaxis.set_major_formatter(ticker.NullFormatter())
        ax.yaxis.set_minor_locator(ticker.FixedLocator([i + 0.5 for i in np.arange(board_size)]))
        ax.yaxis.set_minor_formatter(ticker.FixedFormatter(np.arange(board_size)))

    anim = FuncAnimation(fig, update, frames=len(times), interval=100, repeat=False)    # Create the animation.

    # Save the animation as a GIF using PillowWriter.
    writer = PillowWriter(fps=10)
    anim.save(f"game_of_life/output/{animation_name}.gif", writer=writer)

    # Alternatively, you can show the animation using plt.show().
    #plt.show() 
 
# Function to capture the board size.
def parse_args():
    import argparse
    parser = argparse.ArgumentParser(description='Plot the output of the simulation.')
    parser.add_argument('-b', '--board_size', type=int, help='Size of the board used in the simulation.')
    parser.add_argument('-o', '--output', type=str, help='Name of the animation file.')
    args = parser.parse_args()
    return args


if __name__ == "__main__":
    args = parse_args()
    times, x_coords, y_coords = read_output(args.board_size)
    print(times)
    print(x_coords)
    print(y_coords)
    make_animation(times, x_coords, y_coords, args.board_size, args.output)
    
    # If you want to test, frame by frame, the output of the simulation, uncomment the following line.
    #test_plot(times, x_coords, y_coords, args.board_size)